import numpy as np
from sympy import isprime, Matrix
from collections import deque
from typing import List, Dict, Any, Optional, Generator
from power_graph.core.groups.group import Group

class GLGroup(Group):
    """
    General Linear Group GL(n, p) using a set of generators (bases).
    
    Only the generators are stored in `self.elements` as NumPy arrays.
    Full group traversal can be done dynamically when needed.
    """

    def __init__(self, n: int, p: int, generators: Optional[List[np.ndarray]] = None) -> None:
        if not isprime(p):
            raise ValueError(f"Modulus p must be prime, got p={p}")

        super().__init__()
        self._n: int = n
        self._p: int = p
        self.identity: np.ndarray = np.eye(n, dtype=int)

        if generators:
            self.elements: List[np.ndarray] = [np.array(g, dtype=int) % p for g in generators]
        else:
            self.elements: List[np.ndarray] = self._generate_standard_generators()

    # --------------------- Internal generators --------------------- #

    def _generate_standard_generators(self) -> List[np.ndarray]:
        generators: List[np.ndarray] = [self.identity.copy()]

        # Transvection matrices T_ij(1)
        for i in range(self._n):
            for j in range(self._n):
                if i != j:
                    mat = np.eye(self._n, dtype=int)
                    mat[i, j] = 1
                    generators.append(mat)

        # Dilation matrices D_i(alpha) for alpha in {2,...,p-1}
        for i in range(self._n):
            for alpha in range(2, self._p):
                mat = np.eye(self._n, dtype=int)
                mat[i, i] = alpha % self._p
                generators.append(mat)

        return generators

    def _hashable_matrix(self, mat: np.ndarray) -> tuple:
        return tuple(map(tuple, mat))

    # --------------------- Getters --------------------- #

    def get_modulus(self) -> int:
        return self._p

    def get_dimension(self) -> int:
        return self._n

    def get_elements(self) -> List[np.ndarray]:
        return self.elements

    def get_identity(self) -> np.ndarray:
        return self.identity

    def get_order(self) -> int:
        """Return the number of stored generators (not full group order)."""
        return len(self.elements)

    def get_full_group_order(self) -> int:
        order = 1
        for i in range(self._n):
            order *= (self._p**self._n - self._p**i)
        return order

    def get_element_labels(self) -> Dict[tuple, np.ndarray]:
        return {self._hashable_matrix(mat): mat for mat in self.elements}

    # --------------------- Operations --------------------- #

    def multiply(self, a: np.ndarray, b: np.ndarray) -> np.ndarray:
        """Multiply two matrices modulo p."""
        return np.matmul(a, b) % self._p

    def power(self, a: np.ndarray, exponent: int) -> np.ndarray:
        """Compute a^exponent using binary exponentiation modulo p."""
        result = np.eye(self._n, dtype=int)
        base = a.copy()
        k = exponent
        while k > 0:
            if k % 2 == 1:
                result = self.multiply(result, base)
            base = self.multiply(base, base)
            k //= 2
        return result

    def inverse(self, a: np.ndarray) -> np.ndarray:
        """Compute the inverse of a matrix modulo p."""
        return np.array(Matrix(a.tolist()).inv_mod(self._p), dtype=int) % self._p

    def get_element_order(self, a: np.ndarray) -> Optional[int]:
        """Return the order of a matrix element in GL(n, p) using binary exponentiation."""
        max_order = self.get_full_group_order()
        for k in range(1, max_order + 1):
            if np.array_equal(self.power(a, k), self.identity):
                return k
        return None

    # --------------------- BFS traversal --------------------- #

    def bfs_generate(self, max_elements: int = 100_000) -> Generator[np.ndarray, None, None]:
        """Dynamically traverse all elements generated by self.elements using BFS with safety limit."""
        seen = {self._hashable_matrix(self.identity)}
        queue = deque([self.identity.copy()])

        while queue:
            current = queue.popleft()
            yield current

            for generator in self.elements:
                new_elem = self.multiply(current, generator)
                key = self._hashable_matrix(new_elem)

                if key not in seen:
                    seen.add(key)
                    queue.append(new_elem)

                    if len(seen) >= max_elements:
                        print(f"Reached maximum element limit ({max_elements}), stopping BFS.")
                        return

    def generate_all_elements(self, max_elements: Optional[int] = None) -> List[np.ndarray]:
        if max_elements is None:
            max_elements = self.get_full_group_order()

        elements: List[np.ndarray] = []
        for elem in self.bfs_generate(max_elements=max_elements):
            elements.append(elem)
            if len(elements) >= max_elements:
                break
        return elements

    # --------------------- Print elements --------------------- #

    def print_elements(self, max_bases: int = 10) -> None:
        total_elements = self.get_full_group_order()

        if total_elements <= 10:
            print("All elements of the group:")
            for i, elem in enumerate(self.generate_all_elements(), start=1):
                print(f"{i}:\n{elem}\n")
        else:
            print(f"Group has {total_elements} elements (>10), printing stored generators (up to {max_bases}):\n")
            display_count = min(len(self.elements), max_bases)
            for i in range(display_count):
                print(f"Generator {i+1}:\n{self.elements[i]}\n")
            if len(self.elements) > max_bases:
                print(f"... ({len(self.elements) - max_bases} more generators not shown)")

    def get_generators(self) -> List[Any]:
        raise NotImplementedError("get_generators is not implemented yet.")

    # --------------------- Representation --------------------- #

    def __repr__(self) -> str:
        full_order = self.get_full_group_order()
        return f"GLGroup(GL({self._n}, {self._p}), generators={len(self.elements)}, full_order={full_order})"

