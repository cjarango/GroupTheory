import numpy as np
from sympy import isprime, Matrix
from collections import deque
from typing import List, Dict, Any, Optional, Generator, Set, FrozenSet
from power_graph.core.groups.group import Group
import itertools


class GLGroup(Group):
    """
    General Linear Group GL(n, p) using a set of generators (bases).
    
    Only the generators are stored in `self.elements` as NumPy arrays.
    Full group traversal can be done dynamically when needed.
    """

    def __init__(self, n: int, p: int, generators: Optional[List[np.ndarray]] = None) -> None:
        if not isprime(p):
            raise ValueError(f"Modulus p must be prime, got p={p}")

        super().__init__()
        self._n: int = n
        self._p: int = p
        self.identity: np.ndarray = np.eye(n, dtype=int) % p

        if generators:
            self.elements: List[np.ndarray] = [np.array(g, dtype=int) % p for g in generators]
        else:
            self.elements: List[np.ndarray] = self._generate_standard_generators()

    # --------------------- Internal generators --------------------- #

    def _generate_standard_generators(self) -> List[np.ndarray]:
        generators: List[np.ndarray] = [self.identity.copy()]

        # Transvection matrices T_ij(1)
        for i in range(self._n):
            for j in range(self._n):
                if i != j:
                    mat = np.eye(self._n, dtype=int)
                    mat[i, j] = 1
                    generators.append(mat % self._p)

        # Dilation matrices D_i(alpha) for alpha in {2,...,p-1}
        for i in range(self._n):
            for alpha in range(2, self._p):
                mat = np.eye(self._n, dtype=int)
                mat[i, i] = alpha % self._p
                generators.append(mat % self._p)

        return generators

    def _hashable_matrix(self, mat: np.ndarray) -> bytes:
        """Representación hashable única de una matriz módulo p."""
        return (mat % self._p).astype(int).tobytes()

    # --------------------- Getters --------------------- #

    def get_modulus(self) -> int:
        return self._p

    def get_dimension(self) -> int:
        return self._n

    def get_elements(self) -> List[np.ndarray]:
        return self.elements

    def get_identity(self) -> np.ndarray:
        return self.identity

    def get_order(self) -> int:
        """Return the number of stored generators (not full group order)."""
        return len(self.elements)

    def get_full_group_order(self) -> int:
        order = 1
        for i in range(self._n):
            order *= (self._p**self._n - self._p**i)
        return order

    def get_element_labels(self) -> Dict[bytes, np.ndarray]:
        return {self._hashable_matrix(mat): mat for mat in self.elements}

    # --------------------- Operations --------------------- #

    def multiply(self, a: np.ndarray, b: np.ndarray) -> np.ndarray:
        """Multiply two matrices modulo p."""
        return (np.matmul(a, b) % self._p).astype(int)

    def power(self, a: np.ndarray, exponent: int) -> np.ndarray:
        """Compute a^exponent using binary exponentiation modulo p."""
        result = np.eye(self._n, dtype=int)
        base = a.copy() % self._p
        k = exponent
        while k > 0:
            if k % 2 == 1:
                result = self.multiply(result, base)
            base = self.multiply(base, base)
            k //= 2
        return result % self._p

    def inverse(self, a: np.ndarray) -> np.ndarray:
        """Compute the inverse of a matrix modulo p."""
        return np.array(Matrix(a.tolist()).inv_mod(self._p), dtype=int) % self._p

    def get_element_order(self, a: np.ndarray) -> Optional[int]:
        """Return the order of a matrix element in GL(n, p)."""
        max_order = self.get_full_group_order()
        for k in range(1, max_order + 1):
            if np.array_equal(self.power(a, k), self.identity):
                return k
        return None

    # --------------------- BFS traversal --------------------- #

    def bfs_generate(self, max_elements: int = 100_000) -> Generator[np.ndarray, None, None]:
        """Dynamically traverse all elements generated by self.elements using BFS with safety limit."""
        seen = {self._hashable_matrix(self.identity)}
        queue = deque([self.identity.copy()])

        while queue:
            current = queue.popleft()
            yield current

            for generator in self.elements:
                new_elem = self.multiply(current, generator) % self._p
                key = self._hashable_matrix(new_elem)

                if key not in seen:
                    seen.add(key)
                    queue.append(new_elem)

                    if len(seen) >= max_elements:
                        return

    def generate_all_elements(self, max_elements: Optional[int] = None) -> List[np.ndarray]:
        if max_elements is None:
            max_elements = self.get_full_group_order()

        elements: List[np.ndarray] = []
        for elem in self.bfs_generate(max_elements=max_elements):
            elements.append(elem)
            if len(elements) >= max_elements:
                break
        return elements

    # --------------------- Subgroups --------------------- #

    def generate_subgroup(self, generators: List[np.ndarray]) -> List[np.ndarray]:
        """
        Genera el subgrupo generado por una lista de elementos.
        Incluye los inversos de los generadores.
        """
        # Asegurar que trabajamos con generadores + sus inversos
        gens = []
        for g in generators:
            gens.append(g % self._p)
            gens.append(self.inverse(g))

        seen = {self._hashable_matrix(self.identity)}
        subgroup = [self.identity.copy()]
        queue = deque([self.identity.copy()])

        while queue:
            current = queue.popleft()
            for g in gens:
                new_elem = self.multiply(current, g)
                key = self._hashable_matrix(new_elem)
                if key not in seen:
                    seen.add(key)
                    subgroup.append(new_elem)
                    queue.append(new_elem)
        return subgroup


    def get_all_subgroups(self) -> List[List[np.ndarray]]:
        """
        Devuelve todos los subgrupos de GL(n,p).
        Incluye:
        - el subgrupo trivial
        - todos los subgrupos generados por subconjuntos de elementos
        - el grupo completo
        """
        all_elements = self.generate_all_elements()
        group_order = len(all_elements)

        subgroups: List[List[np.ndarray]] = []
        seen_subgroups: Set[FrozenSet[bytes]] = set()

        # Subgrupo trivial
        trivial = [self.identity.copy()]
        subgroups.append(trivial)
        seen_subgroups.add(frozenset([self._hashable_matrix(self.identity)]))

        # Subgrupos generados por subconjuntos de elementos
        for r in range(1, len(all_elements) + 1):
            for combo in itertools.combinations(all_elements, r):
                subgroup = self.generate_subgroup(list(combo))
                subgroup_set = frozenset(self._hashable_matrix(m) for m in subgroup)

                if (subgroup_set not in seen_subgroups and
                    len(subgroup) > 0 and
                    group_order % len(subgroup) == 0):
                    subgroups.append(subgroup)
                    seen_subgroups.add(subgroup_set)

        return subgroups


    # --------------------- Print elements --------------------- #

    def print_elements(self, max_bases: int = 10) -> None:
        total_elements = self.get_full_group_order()

        if total_elements <= 10:
            print("All elements of the group:")
            for i, elem in enumerate(self.generate_all_elements(), start=1):
                print(f"{i}:\n{elem}\n")
        else:
            print(f"Group has {total_elements} elements (>10), printing stored generators (up to {max_bases}):\n")
            display_count = min(len(self.elements), max_bases)
            for i in range(display_count):
                print(f"Generator {i+1}:\n{self.elements[i]}\n")
            if len(self.elements) > max_bases:
                print(f"... ({len(self.elements) - max_bases} more generators not shown)")

    def get_generators(self) -> List[Any]:
        return self.elements

    # --------------------- Representation --------------------- #

    def __repr__(self) -> str:
        full_order = self.get_full_group_order()
        return f"GLGroup(GL({self._n}, {self._p}), generators={len(self.elements)}, full_order={full_order})"
