from sympy.combinatorics.permutations import Permutation
from power_graph.core.groups import SymmetricGroup
from typing import Any, List, Dict
from sympy.combinatorics import PermutationGroup
from functools import lru_cache


class DihedralGroup(SymmetricGroup):
    """
    Concrete implementation of a dihedral group D_n.
    It is a subgroup of S_n generated by:
    - a rotation (0 1 2 ... n-1)
    - a reflection (symmetry across an axis of the n-gon).
    """

    def __init__(self, n: int) -> None:
        if n < 2:
            raise ValueError("El orden del polígono debe ser al menos 2.")

        self.n = n

        # Rotación generadora: (0 1 2 ... n-1)
        self.rotation = Permutation(list(range(1, n)) + [0])

        # Reflexión generadora: simetría respecto a un eje
        reflection_list = list(range(n))
        for i in range(n // 2):
            reflection_list[i], reflection_list[n - 1 - i] = (
                reflection_list[n - 1 - i],
                reflection_list[i],
            )
        self.reflection = Permutation(reflection_list)

        # Construir D_n como subgrupo de S_n
        dihedral_group = PermutationGroup([self.rotation, self.reflection])
        elements = list(dihedral_group.generate_dimino())

        # Inicializar atributos como en SymmetricGroup
        super().__init__(n)
        self._sym_group = dihedral_group
        self.elements = elements
        self.identity = dihedral_group.identity

    def __repr__(self) -> str:
        return f"DihedralGroup(D_{self.n})"

    # ----------------------------
    # Métodos sobrescritos CRÍTICOS para EngelGraph
    # ----------------------------

    @lru_cache(maxsize=1)
    def get_elements(self) -> List[Any]:
        """Garantizar compatibilidad con cache."""
        return self.elements

    def get_hypercenter(self) -> List[Any]:
        """Devuelve el hipercentro de D_n - MÉTODO CRÍTICO para EngelGraph."""
        series = self._compute_ascending_central_series()
        return series[-1]

    def is_abelian(self) -> bool:
        """D_n es abeliano solo si n <= 2"""
        return self.n <= 2

    def get_center(self) -> List[Any]:
        """
        Centro de D_n:
        - si n <= 2: todo el grupo
        - si n es impar: {e}
        - si n es par: {e, rotación de 180°}
        """
        if self.n <= 2:
            return self.elements  # casos triviales

        if self.n % 2 == 0:
            # rotación de 180° = rot^(n/2)
            half_turn = self.rotation ** (self.n // 2)
            return [self.identity, half_turn]
        return [self.identity]

    def get_conjugacy_classes(self) -> List[List[Any]]:
        """
        Conjugacy classes específicas de D_n.
        Calculadas por definición: Cl(g) = { h g h^{-1} : h in G }.
        """
        classes: List[List[Any]] = []
        used = set()

        for g in self.elements:
            if g in used:
                continue
            conj_class = {h * g * (~h) for h in self.elements}
            classes.append(list(conj_class))
            used.update(conj_class)

        return classes

    # ----------------------------
    # Serie central ascendente y hipercentro - CORREGIDO
    # ----------------------------

    def _compute_ascending_central_series(self):
        """
        Serie central ascendente para D_n.
        Para n > 2, el hipercentro es el centro.
        """
        series = [[self.identity]]
        
        if self.n <= 2:
            series.append(self.elements)
            return series
            
        if self.n % 2 == 1:  # n impar
            return series  # Se estanca en Z0
        
        # n PAR - SIEMPRE el centro para n > 2
        series.append(self.get_center())
        return series

    # ----------------------------
    # Métodos adicionales para mejor integración
    # ----------------------------

    def get_element_labels(self, one_indexed: bool = True) -> Dict[Any, str]:
        """Etiquetas específicas para elementos de D_n."""
        labels = {}
        for el in self.get_elements():
            # Identificar si es rotación o reflexión
            if el == self.identity:
                labels[el] = "e"
            elif el in [self.rotation ** k for k in range(1, self.n)]:
                # Es una rotación
                k = 1
                current = self.rotation
                while current != el and k < self.n:
                    k += 1
                    current = self.rotation ** k
                labels[el] = f"r^{k}" if k > 1 else "r"
            else:
                # Es una reflexión
                k = 0
                current = self.reflection
                while current != el and k < self.n:
                    k += 1
                    current = self.reflection * (self.rotation ** k)
                labels[el] = f"s·r^{k}" if k > 0 else "s"
        return labels