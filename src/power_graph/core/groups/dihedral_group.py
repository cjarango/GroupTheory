from sympy.combinatorics.permutations import Permutation
from power_graph.core.groups import SymmetricGroup
from typing import Any, List, Dict
from sympy.combinatorics import PermutationGroup
from functools import lru_cache


class DihedralGroup(SymmetricGroup):
    """
    Concrete implementation of a dihedral group D_n.
    It is a subgroup of S_n generated by:
    - a rotation (0 1 2 ... n-1)
    - a reflection (symmetry across an axis of the n-gon).
    """

    def __init__(self, n: int) -> None:
        if n < 2:
            raise ValueError("El orden del polígono debe ser al menos 2.")

        self.n = n

        # Rotación generadora: (0 1 2 ... n-1)
        self.rotation = Permutation(list(range(1, n)) + [0])

        # Reflexión generadora: simetría respecto a un eje
        reflection_list = list(range(n))
        for i in range(n // 2):
            reflection_list[i], reflection_list[n - 1 - i] = (
                reflection_list[n - 1 - i],
                reflection_list[i],
            )
        self.reflection = Permutation(reflection_list)

        # Construir D_n como subgrupo de S_n
        dihedral_group = PermutationGroup([self.rotation, self.reflection])
        
        # Inicializar SymmetricGroup con n, pero luego sobreescribir
        super().__init__(n)
        self._sym_group = dihedral_group
        self.identity = dihedral_group.identity
        # Limpiar cache de elementos para forzar recálculo
        self.get_elements.cache_clear()

    def __repr__(self) -> str:
        return f"DihedralGroup(D_{self.n})"

    # ----------------------------
    # Métodos sobrescritos CRÍTICOS para EngelGraph
    # ----------------------------

    @lru_cache(maxsize=1)
    def get_elements(self) -> List[Any]:
        """Garantizar que usamos los elementos de D_n, no de S_n."""
        return list(self._sym_group.generate_dimino())

    def is_abelian(self) -> bool:
        """D_n es abeliano solo si n <= 2"""
        return self.n <= 2

    def get_center(self) -> List[Any]:
        """
        Centro de D_n:
        - si n <= 2: todo el grupo
        - si n es impar: {e}
        - si n es par: {e, rotación de 180°}
        """
        if self.n <= 2:
            return self.get_elements()

        if self.n % 2 == 0:
            # rotación de 180° = rot^(n/2)
            half_turn = self.rotation ** (self.n // 2)
            return [self.identity, half_turn]
        return [self.identity]

    def get_conjugacy_classes(self) -> List[List[Any]]:
        """
        Conjugacy classes específicas de D_n.
        Calculadas por definición: Cl(g) = { h g h^{-1} : h in G }.
        """
        elements = self.get_elements()
        classes: List[List[Any]] = []
        used = set()

        for g in elements:
            if g in used:
                continue
            conj_class = {h * g * (~h) for h in elements}
            classes.append(list(conj_class))
            used.update(conj_class)

        return classes

    # ----------------------------
    # Serie central ascendente y hipercentro - CORREGIDO MATEMÁTICAMENTE
    # ----------------------------

    def _is_power_of_two(self, n: int) -> bool:
        """Verifica si n es potencia de 2."""
        return (n & (n - 1)) == 0 and n > 0

    def _compute_ascending_central_series(self) -> List[List[Any]]:
        """
        Serie central ascendente CORREGIDA para D_n.
        
        Teorema:
        - Si n ≤ 2: D_n es abeliano → Z₀ = {e}, Z₁ = G
        - Si n > 2 y n NO es potencia de 2: Z₀ = {e}, Z₁ = Z(D_n) (se estabiliza)
        - Si n > 2 y n es potencia de 2: D_n es nilpotente → serie completa hasta G
        """
        if hasattr(self, "_ascending_central_series"):
            return self._ascending_central_series

        Z0 = [self.identity]
        
        # Caso n ≤ 2: grupo abeliano
        if self.n <= 2:
            series = [Z0, self.get_elements()]
        else:
            Z1 = self.get_center()
            
            if self._is_power_of_two(self.n):
                # Para n potencia de 2: D_n es nilpotente de clase 2
                # Z₀ ⊆ Z₁ ⊆ Z₂ = G
                series = [Z0, Z1, self.get_elements()]
            else:
                # Para n no potencia de 2: Z₀ ⊆ Z₁ (se estabiliza)
                series = [Z0, Z1]

        self._ascending_central_series = series
        return series

    def get_hypercenter(self) -> List[Any]:
        """
        Hipercentro CORREGIDO de D_n.
        
        Teorema:
        - Si n ≤ 2: Z∞(D_n) = D_n (abeliano)
        - Si n es potencia de 2: Z∞(D_n) = D_n (nilpotente)  
        - En otro caso: Z∞(D_n) = Z(D_n)
        """
        series = self._compute_ascending_central_series()
        return series[-1]

    def is_nilpotent(self) -> bool:
        """
        Determina si D_n es nilpotente.
        
        Teorema: D_n es nilpotente si y solo si n es potencia de 2.
        """
        return self._is_power_of_two(self.n)

    # ----------------------------
    # Métodos adicionales para mejor integración
    # ----------------------------

    def get_element_labels(self, one_indexed: bool = True) -> Dict[Any, str]:
        """Etiquetas específicas para elementos de D_n."""
        labels = {}
        for el in self.get_elements():
            # Identificar si es rotación o reflexión
            if el == self.identity:
                labels[el] = "e"
            elif el in [self.rotation ** k for k in range(1, self.n)]:
                # Es una rotación
                k = 1
                current = self.rotation
                while current != el and k < self.n:
                    k += 1
                    current = self.rotation ** k
                labels[el] = f"r^{k}" if k > 1 else "r"
            else:
                # Es una reflexión
                k = 0
                current = self.reflection
                while current != el and k < self.n:
                    k += 1
                    current = self.reflection * (self.rotation ** k)
                labels[el] = f"s·r^{k}" if k > 0 else "s"
        return labels

    def print_ascending_central_series(self, one_indexed: bool = False) -> None:
        """Pretty print de la serie central ascendente."""
        labels = self.get_element_labels(one_indexed=one_indexed)
        series = self._compute_ascending_central_series()
        
        print(f"Serie Central Ascendente de D_{self.n}:")
        for i, Zi in enumerate(series):
            element_labels = [labels[g] for g in Zi]
            print(f"Z{i}(G) = {{{', '.join(element_labels)}}} (tamaño: {len(Zi)})")
        
        # Información adicional sobre nilpotencia
        if self.is_nilpotent():
            print(f"✓ D_{self.n} es nilpotente (n={self.n} es potencia de 2)")
            print(f"✓ Clase de nilpotencia: {len(series) - 1}")
        else:
            print(f"✗ D_{self.n} no es nilpotente (n={self.n} no es potencia de 2)")