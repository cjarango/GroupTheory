from itertools import combinations
from typing import Any, List, Set, Dict
from power_graph.core.groups import SymmetricGroup, CyclicGroup
from power_graph.core.graphs.group_graph import GroupGraph


class FactorizationGraph(GroupGraph):
    """
    Factorization graph of a finite group.
    Vertices: proper subgroups of G.
    Two subgroups H and K are adjacent iff G = HK.
    """

    def __init__(self, group: Any, identity: bool = False, verbose: bool = False) -> None:
        if not isinstance(group, (SymmetricGroup, CyclicGroup)):
            raise TypeError("Only SymmetricGroup and CyclicGroup are supported.")
        if len(group) <= 1:
            raise ValueError("Group must have more than one element")

        self.identity = identity
        super().__init__(group, directed=False, verbose=verbose)

    # ---------------------- Private methods ---------------------- #
    def _closure(self, generators) -> frozenset:
        """Compute subgroup generated by `generators`."""
        if not generators:
            return frozenset([self.group.get_identity()]) if self.identity else frozenset()

        elements = set(generators)
        if self.identity:
            elements.add(self.group.get_identity())

        changed = True
        while changed:
            changed = False
            new_elements = set(elements)
            for a in elements:
                for b in elements:
                    product = self.group.multiply(a, b)
                    if product not in elements:
                        new_elements.add(product)
                        changed = True
            elements = new_elements

        return frozenset(elements)

    def _get_proper_subgroups(self) -> List[frozenset]:
        """Get all proper subgroups of the group (excluding G)."""
        subgroups = set()
        elements = self.group.get_elements()
        group_size = len(elements)

        if isinstance(self.group, CyclicGroup):
            # Subgrupos de un grupo cÃ­clico
            n = group_size
            g = self.group.get_generators()[0]
            start = 1 if self.identity else 2
            for d in range(start, n):
                if n % d == 0:
                    H = frozenset([g**(k * (n // d)) for k in range(d)])
                    subgroups.add(H)
        else:  # SymmetricGroup / dihedral
            processed: Set[Any] = set()
            # Generar subgrupos a partir de cada elemento
            for g in elements:
                H = self._closure([g])
                if 1 < len(H) < group_size:
                    subgroups.add(H)
                processed.update(H)

            # Combinaciones de 2 elementos
            for g1, g2 in combinations(elements, 2):
                H = self._closure([g1, g2])
                if 1 < len(H) < group_size:
                    subgroups.add(H)
                processed.update(H)

        if self.verbose:
            print(f"ðŸ”Ž Encontrados {len(subgroups)} subgrupos propios.")
        return list(subgroups)

    def _subgroup_label(self, H: frozenset) -> str:
        """Label subgroups using elements (shortened for large subgroups)."""
        if len(H) > 10:
            sample = list(H)[:5]
            return "{" + ", ".join(map(str, sample)) + ", ...}"
        elems_str = sorted(map(str, H))
        return "{" + ", ".join(elems_str) + "}"

    def _is_factorization(self, H: frozenset, K: frozenset) -> bool:
        # 1. Filtro rÃ¡pido por cardinalidad
        intersection = H & K
        required_size = (len(H) * len(K)) / len(intersection)
        if abs(required_size - len(self.group)) > 1e-9:
            return False

        # 2. VerificaciÃ³n completa del producto
        G_elements = set(self.group.get_elements())
        HK = set()
        for h in H:
            for k in K:
                HK.add(self.group.multiply(h, k))
                if len(HK) == len(G_elements):  # Early stop
                    break
            if len(HK) == len(G_elements):
                break

        return HK == G_elements

    def _build_graph(self) -> None:
        """Construct the factorization graph."""
        self._subgroups = self._get_proper_subgroups()
        self._labels = {H: self._subgroup_label(H) for H in self._subgroups}
        self.graph.add_nodes_from(self._subgroups)

        if self.verbose:
            print("ðŸ”— Construyendo aristas de factorizaciÃ³n...")

        for i, H in enumerate(self._subgroups):
            for K in self._subgroups[i + 1:]:
                if self._is_factorization(H, K):
                    self.graph.add_edge(H, K)

        if self.verbose:
            print(f"âœ… Grafo construido: {len(self._subgroups)} nodos, {self.graph.number_of_edges()} aristas")
