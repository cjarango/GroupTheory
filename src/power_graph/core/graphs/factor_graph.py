import networkx as nx
import matplotlib.pyplot as plt
import matplotlib.patches as mpatches
import pandas as pd
from typing import Any, Dict, Optional, List, Set
from itertools import combinations
from power_graph.core.groups import SymmetricGroup, CyclicGroup


class FactorizationGraph:
    """
    Factorization graph of a finite group.
    Vertices: proper subgroups of G.
    Two subgroups H and K are adjacent iff G = HK.
    """

    def __init__(self, group: Any, identity: bool = False, verbose: bool = False) -> None:
        if not isinstance(group, (SymmetricGroup, CyclicGroup)):
            raise TypeError("Only SymmetricGroup and CyclicGroup are supported.")
        if len(group) <= 1:
            raise ValueError("Group must have more than one element")
            
        self.group = group
        self.identity = identity
        self.verbose = verbose
        self.graph = nx.Graph()
        self._subgroups: List[frozenset] = []
        self._labels: Dict[frozenset, str] = {}
        self._build_graph()

    # ---------------------- Public methods ---------------------- #
    def draw(self, ax=None, title: Optional[str] = None,
             node_color: str = 'lightgreen', node_size: int = 1000, 
             show_legend: bool = True, **kwargs) -> None:
        """Draw the factorization graph with optional subgroup labels in the legend."""
        if not self.graph.nodes:
            print("⚠️ No hay subgrupos propios para dibujar.")
            return

        if ax is None:
            fig, ax = plt.subplots(figsize=kwargs.pop("figsize", (10, 7)))

        nodes = list(self.graph.nodes)
        node_labels = {node: i + 1 for i, node in enumerate(nodes)}

        pos = kwargs.pop("pos", nx.spring_layout(self.graph, seed=42))
        nx.draw(self.graph, pos=pos, labels=node_labels, node_color=node_color,
                node_size=node_size, ax=ax, **kwargs)

        if show_legend:
            legend_texts = []
            for node, number in node_labels.items():
                subgroup = self._labels[node]
                patch = mpatches.Patch(facecolor='none', edgecolor='none',
                                        label=f"{number}: {subgroup}")
                legend_texts.append(patch)
            ax.legend(handles=legend_texts, loc='upper right', frameon=False, fontsize=8)

        if title:
            ax.set_title(title)
        ax.axis('off')

    def summarize(self) -> Dict[str, Any]:
        G = self.graph
        num_nodes = G.number_of_nodes()
        num_edges = G.number_of_edges()
        num_components = nx.number_connected_components(G)
        degrees = [d for n, d in G.degree()]

        df = pd.DataFrame([{
            "Nodos": num_nodes,
            "Aristas": num_edges,
            "Partes conexas": num_components,
            "Grado máximo": max(degrees) if degrees else 0,
            "Grado mínimo": min(degrees) if degrees else 0
        }])

        adjacency = nx.to_numpy_array(G, nodelist=list(G.nodes), dtype=int)
        incidence = nx.incidence_matrix(G, nodelist=list(G.nodes)).toarray()

        return {
            "summary": df,
            "adjacency_matrix": adjacency,
            "incidence_matrix": incidence
        }

    def __repr__(self) -> str:
        return (f"FactorizationGraph(Group={type(self.group).__name__}, "
                f"Nodes={self.graph.number_of_nodes()}, Edges={self.graph.number_of_edges()})")

    # ---------------------- Private methods ---------------------- #
    def _closure(self, generators) -> frozenset:
        """Compute subgroup generated by `generators`."""
        if not generators:
            return frozenset([self.group.get_identity()]) if self.identity else frozenset()
        
        elements = set(generators)
        if self.identity:
            elements.add(self.group.get_identity())
        
        changed = True
        while changed:
            changed = False
            new_elements = set(elements)
            for a in elements:
                for b in elements:
                    product = self.group.multiply(a, b)
                    if product not in elements:
                        new_elements.add(product)
                        changed = True
            elements = new_elements
        
        return frozenset(elements)

    def _get_proper_subgroups(self) -> List[frozenset]:
        """Get all proper subgroups of the group (excluding G)."""
        subgroups = set()
        elements = self.group.get_elements()
        identity = self.group.get_identity()
        group_size = len(elements)

        if isinstance(self.group, CyclicGroup):
            # Subgrupos de un grupo cíclico
            n = group_size
            g = self.group.get_generators()[0]
            start = 1 if self.identity else 2
            for d in range(start, n):
                if n % d == 0:
                    H = frozenset([g**(k * (n // d)) for k in range(d)])
                    subgroups.add(H)
        else:  # SymmetricGroup / dihedral
            processed: Set[Any] = set()
            # Generar subgrupos a partir de cada elemento
            for g in elements:
                H = self._closure([g])
                if 1 < len(H) < group_size:
                    subgroups.add(H)
                processed.update(H)

            # Combinaciones de 2 elementos para D_n
            for g1, g2 in combinations(elements, 2):
                H = self._closure([g1, g2])
                if 1 < len(H) < group_size:
                    subgroups.add(H)
                processed.update(H)

        if self.verbose:
            print(f"🔎 Encontrados {len(subgroups)} subgrupos propios.")
        return list(subgroups)

    def _subgroup_label(self, H: frozenset) -> str:
        """Label subgroups using elements (shortened for large subgroups)."""
        if len(H) > 10:
            sample = list(H)[:5]
            return "{" + ", ".join(map(str, sample)) + ", ...}"
        # Convertir a string antes de ordenar
        elems_str = sorted(map(str, H))
        return "{" + ", ".join(elems_str) + "}"

    def _is_factorization(self, H: frozenset, K: frozenset) -> bool:
        """Check if H * K = G."""
        G_elements = set(self.group.get_elements())
        HK = {self.group.multiply(h, k) for h in H for k in K}
        return HK == G_elements

    def _build_graph(self) -> None:
        """Construct the factorization graph."""
        self._subgroups = self._get_proper_subgroups()
        self._labels = {H: self._subgroup_label(H) for H in self._subgroups}
        self.graph.add_nodes_from(self._subgroups)

        if self.verbose:
            print("🔗 Construyendo aristas de factorización...")
        
        for i, H in enumerate(self._subgroups):
            for K in self._subgroups[i + 1:]:
                if self._is_factorization(H, K):
                    self.graph.add_edge(H, K)
        
        if self.verbose:
            print(f"✅ Grafo construido: {len(self._subgroups)} nodos, {self.graph.number_of_edges()} aristas")
